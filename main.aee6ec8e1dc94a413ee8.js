(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{"93cA":function(n,e,t){n.exports=t.p+"c37b97b969656107e679d7ad8ef77a79.woff"},J6RI:function(n,e,t){e=n.exports=t("JPst")(!1);var o=t("HeW1"),r=o(t("aZUD")),i=o(t("93cA")),a=o(t("cEfc"));e.push([n.i,'\n/* COLOR PALETTE */\n:root {\n    --GR1: #191a1d;\n    --GR2: #202124;\n    --GR3: #2d2e30;\n    --GR4: #3f4042;\n    --GR5: #d9d9d9;\n}\n\n/* GLOBAL */\nbody {\n    margin: 0;\n    background-color: var(--GR1);\n}\n\n#globe {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: -1;\n}\n\n/* FONTS */\n@font-face {\n    font-family: "din";\n    src: url('+r+") format('woff');\n}\n@font-face {\n    font-family: \"din\";\n    src: url("+i+") format('woff');\n    font-weight: bold;\n}\n@font-face {\n    font-family: \"din\";\n    src: url("+a+") format('woff');\n    font-style: italic;\n}\n* { font-family: \"din\" }\n\n/* HEADER */\nheader {\n    color: var(--GR5);\n    font-weight: bold;\n    width: 100%;\n    height: 95%;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 0;\n    z-index: -1;\n}\nheader .main {\n    margin: auto;\n    margin-left: 2%;\n    width: 46%;\n    padding-top: 5%;\n}\nheader .pretitle {\n    font-size: 4em;\n}\nheader .title {\n    font-size: 7em;\n}\n\n/* SECTIONS */\nsection {\n    width: 100%;\n    height: 95%;\n}\n\nsection h1 {\n    padding-top: 0.5em;\n    margin-top: 0;\n    font-size: 5em;\n    text-align: center;\n}\n\n/* NAV */\nnav {\n    width: 100%;\n    height: 5%;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 0;\n    background-color: var(--GR5);\n}\n\n.dark {\n    color: var(--GR5);\n    background-color: var(--GR1);\n}\n.gray {\n    color: var(--GR5);\n    background-color: var(--GR4);\n}\n.white {\n    color: var(--GR2);\n    background-color: var(--GR5);\n}\n\n\n.test {\n    position: relative;\n}",""])},OMi8:function(n,e,t){var o=t("J6RI");"string"==typeof o&&(o=[[n.i,o,""]]);var r={insert:"head",singleton:!1};t("LboF")(o,r);o.locals&&(n.exports=o.locals)},aZUD:function(n,e,t){n.exports=t.p+"7d2271b97e1fc197a8410ec269814cbc.woff"},cEfc:function(n,e,t){n.exports=t.p+"e6713781e2b16fe3b5fafd8117433ee4.woff"},tjUo:function(n,e,t){"use strict";t.r(e);t("OMi8");var c=t("Womt");function l(n){return(l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function f(n){return(f=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function d(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function o(n,e){return(o=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}var s=function(){function s(){var e,n=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,s);var t=new c.a;t.addAttribute("vertexPos",new c.d([1,1,0,-1,1,0,1,-1,0,-1,-1,0],3)),t.setIndex([0,1,2,1,3,2]);var o=(new c.l).load("assets/earth/earth-day.jpg"),r=(new c.l).load("assets/earth/earth-aux.jpg"),i=(new c.l).load("assets/earth/earth-nrm.jpg");o.minFilter=c.e,r.minFilter=c.e,i.minFilter=c.e;var a=new c.j({uniforms:{invViewMatrix:{value:new c.f},size:{value:1},dayTex:{type:"t",value:o},auxTex:{type:"t",value:r},nrmTex:{type:"t",value:i}},vertexShader:"precision highp float;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 invViewMatrix;\n\nuniform vec3 cameraPosition;\n\nuniform float size;\n\nattribute vec3 vertexPos;\nvarying vec3 fragPos;\n\n// sPos : position of sphere in 2D, where the Y should be perpendicular to camera plane\n// s    : sign for either min or max of sphere on X axis of sPos\n// returns additional correction on X axis due to projection\nfloat perspectiveCorrect(vec2 sPos, float s) {\n    float l = sqrt(pow(sPos.y, 2.0) + pow(sPos.x, 2.0));\n    float a = asin(sPos.x / l);\n    float b = asin(size / l) * s;\n    return ((size / cos(a + b)) - size) * s;\n}\n\nvoid main() {\n    /* \n       first we multiply the matrices together for positioning\n       then set rotation part to identity for a billboard effect\n       (where the render plane is always parallel with the near plane)\n    */\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n    // first column\n    modelViewMatrix[0][0] = 1.0; \n    modelViewMatrix[0][1] = 0.0; \n    modelViewMatrix[0][2] = 0.0; \n\n    // second column\n    modelViewMatrix[1][0] = 0.0; \n    modelViewMatrix[1][1] = 1.0; \n    modelViewMatrix[1][2] = 0.0; \n\n    // third column\n    modelViewMatrix[2][0] = 0.0; \n    modelViewMatrix[2][1] = 0.0; \n    modelViewMatrix[2][2] = 1.0; \n\n    // position of render plane vertex relative to camera\n    vec4 viewPos = modelViewMatrix * vec4(vertexPos, 1);\n\n    // position of sphere center relative to camera\n    vec4 spherePos = viewMatrix * modelMatrix[3];\n\n    // extend plane sides for complete render of sphere\n    viewPos.x += perspectiveCorrect(spherePos.xz, vertexPos.x);\n    viewPos.y += perspectiveCorrect(spherePos.yz, vertexPos.y);\n\n    // forward world pos of vertex to fragment shader\n    fragPos = (invViewMatrix * viewPos).xyz;\n\n    // corner positions of plane\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"precision highp float;\n\n#define lightDir normalize(vec3(1, 0.3, 1))\n#define pi 3.14159265359\n\nuniform vec3 cameraPosition;\nuniform float size;\nuniform mat4 invViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sampler2D dayTex;\nuniform sampler2D nrmTex;\nuniform sampler2D auxTex;\n\nvarying vec3 fragPos;\n\nbool Sphere(vec3 ray, vec3 pos, float radius, out vec2 dist);\nvec3 MapUV(vec3 normal, vec3 ray);\n\nvoid main() {\n    vec3 ray = normalize(cameraPosition - fragPos);\n\n    vec2 test;\n    if (Sphere(ray, cameraPosition, size, test)) {\n\n        vec3 worldPos = (ray * test.x);\n        vec3 normalDir = normalize(cameraPosition - worldPos);\n\n        vec3 color = MapUV(normalDir, ray);\n\n        gl_FragColor = vec4(color, 1);\n\n        return;\n    }\n\n    gl_FragColor = vec4(vec3(0), 1);\n}\n\nbool Sphere(vec3 ray, vec3 pos, float radius, out vec2 dist) {\n    dist = vec2(0, 0);\n    vec2 t;\n    vec3 L = -pos;\n\n    float a = dot(ray, ray);\n    float b = 2.0 * dot(ray, L);\n    float c = dot(L, L) - pow(radius, 2.0);\n\n    float discr = b * b - 4.0 * a * c;\n\n    if (discr < 0.0) {\n        return false;\n    } else if (discr == 0.0)\n    {\n        t.x = (-0.5 * b) / a;\n        t.y = t.x;\n    } else {\n        float q = b > 0.0 ?\n            -0.5 * (b + sqrt(discr)) :\n        -0.5 * (b - sqrt(discr));\n\n        t = vec2(q / a, c / q);\n    }\n\n    if (t.x > t.y) {\n        t = t.yx;\n    }\n    dist = t;\n    return true;\n}\n\nvec3 MapUV(vec3 normalDir, vec3 ray) {\n    vec2 uv = vec2(\n        0.5 + atan(normalDir.z, -normalDir.x) / (pi * 2.0),\n        0.5 - asin(-normalDir.y) / pi\n    );\n\n    // texture mapping\n    vec3 dayMap = texture2D(dayTex, uv).rgb;\n    vec3 normalMap = texture2D(nrmTex, uv).rgb * 2.0 - 1.0;\n    vec3 auxMap = texture2D(auxTex, uv).rgb;\n    \n    float lit = auxMap.r;\n    float specular = auxMap.g;\n    float cloud = auxMap.b;\n\n\n    // for a stable light\n    vec3 staticLightDir = (invViewMatrix * vec4(lightDir, 0)).rgb;\n\n    // reflection of water\n    vec3 reflectDir = reflect(-staticLightDir, normalDir);\n    float reflectAmount = pow(max(dot(ray, reflectDir), 0.0), 6.0) * specular;\n\n    dayMap += vec3(reflectAmount) / 2.0;\n\n    // clouds\n    dayMap = mix(dayMap, vec3(1), vec3(cloud));\n\n    // normal mapping\n    vec3 npole = (modelMatrix * vec4(0, 1, 0, 0)).xyz;\n    vec3 tangent = -cross(normalDir, npole);\n    vec3 biTangent = -cross(tangent, normalDir);\n    mat3 tbn = mat3(tangent, biTangent, normalDir);\n\n    vec3 normalMapDir = tbn * normalMap;\n\n    // lighting of earth\n    float shadow = max(0.01, dot(normalMapDir, staticLightDir));\n    dayMap *= shadow;\n\n    dayMap += lit * pow((1.0 - shadow), 4.0);\n\n    return dayMap;\n}"});return function(n,e,t){e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t}(d(e=function(n,e){return!e||"object"!==l(e)&&"function"!=typeof e?d(n):e}(this,f(s).call(this,t,a))),"setSphereSize",function(n){e.material.uniforms.size.value=n}),e.size=n,e.onBeforeRender=function(n,e,t,o,r){r.uniforms.invViewMatrix.value=t.matrixWorld},e}return function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&o(n,e)}(s,c["g"]),s}();function p(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}new function n(e){var o=this;!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),p(this,"loop",function(n,e){var t=n.getDelta();o.objc.rotateY(t/3),o.renderer.render(o.scene,o.camera),requestAnimationFrame(o.loop.bind(null,n,e))}),p(this,"onWindowResize",function(){var n=o.renderer.domElement,e=(window.devicePixelRatio,n.clientWidth),t=n.clientHeight;o.camera.aspect=e/t,o.camera.updateProjectionMatrix(),o.renderer.setSize(n.clientWidth,n.clientHeight,!1)}),this.scene=new c.k,this.camera=new c.i(20,window.innerWidth/window.innerHeight,.1,1e3),this.objc=new c.h;var t=new c.h;this.scene.add(this.objc),t.position.z=10,this.objc.add(t),t.add(this.camera);var r=new s;this.scene.add(r),r.setSphereSize(1),this.renderer=new c.m({canvas:e}),this.renderer.setClearColor(new c.c("black")),this.onWindowResize();var i=new c.b(!0),a=document.getElementById("fps");this.loop(i,a),window.addEventListener("resize",this.onWindowResize,!1)}(document.getElementById("globe"))}},[["tjUo",4,1,2,3]]]);