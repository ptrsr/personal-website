(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{"93cA":function(n,e,t){n.exports=t.p+"c37b97b969656107e679d7ad8ef77a79.woff"},J6RI:function(n,e,t){e=n.exports=t("JPst")(!1);var r=t("HeW1"),o=r(t("aZUD")),i=r(t("93cA")),a=r(t("cEfc"));e.push([n.i,'\n/* COLOR PALETTE */\n:root {\n    --GR1: #191a1d;\n    --GR2: #202124;\n    --GR3: #2d2e30;\n    --GR4: #3f4042;\n    --GR5: #d9d9d9;\n}\n\n/* GLOBAL */\nbody {\n    margin: 0;\n    background-color: var(--GR1);\n}\n\n#globe {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: -1;\n}\n\n/* FONTS */\n@font-face {\n    font-family: "din";\n    src: url('+o+") format('woff');\n}\n@font-face {\n    font-family: \"din\";\n    src: url("+i+") format('woff');\n    font-weight: bold;\n}\n@font-face {\n    font-family: \"din\";\n    src: url("+a+") format('woff');\n    font-style: italic;\n}\n* { font-family: \"din\" }\n\n/* HEADER */\nheader {\n    color: var(--GR5);\n    font-weight: bold;\n    width: 100%;\n    height: 95%;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 0;\n    z-index: -1;\n}\nheader .main {\n    margin: auto;\n    margin-left: 2%;\n    width: 46%;\n    padding-top: 5%;\n}\nheader .pretitle {\n    font-size: 4em;\n}\nheader .title {\n    font-size: 7em;\n}\n\n/* SECTIONS */\nsection {\n    width: 100%;\n    height: 95%;\n}\n\nsection h1 {\n    padding-top: 0.5em;\n    margin-top: 0;\n    font-size: 5em;\n    text-align: center;\n}\n\n/* NAV */\nnav {\n    width: 100%;\n    height: 5%;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 0;\n    background-color: var(--GR5);\n}\n\n.dark {\n    color: var(--GR5);\n    background-color: var(--GR1);\n}\n.gray {\n    color: var(--GR5);\n    background-color: var(--GR4);\n}\n.white {\n    color: var(--GR2);\n    background-color: var(--GR5);\n}\n\n\n.test {\n    position: relative;\n}",""])},OMi8:function(n,e,t){var r=t("J6RI");"string"==typeof r&&(r=[[n.i,r,""]]);var o={insert:"head",singleton:!1};t("LboF")(r,o);r.locals&&(n.exports=r.locals)},aZUD:function(n,e,t){n.exports=t.p+"7d2271b97e1fc197a8410ec269814cbc.woff"},cEfc:function(n,e,t){n.exports=t.p+"e6713781e2b16fe3b5fafd8117433ee4.woff"},tjUo:function(n,e,t){"use strict";t.r(e);t("OMi8");var l=t("Womt");function r(n){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function s(n,e){return!e||"object"!==r(e)&&"function"!=typeof e?function(n){if(void 0!==n)return n;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(n):e}function f(n){return(f=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function o(n,e){return(o=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}var c=function(){function c(){var n,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,c);var t=new l.a;t.addAttribute("vertexPos",new l.d([1,1,0,-1,1,0,1,-1,0,-1,-1,0],3)),t.setIndex([0,1,2,1,3,2]);var r=(new l.l).load("assets/earth/earth-day.jpg"),o=(new l.l).load("assets/earth/earth-aux.jpg"),i=(new l.l).load("assets/earth/earth-nrm.jpg");r.minFilter=l.e,o.minFilter=l.e,i.minFilter=l.e;var a=new l.j({uniforms:{invViewMatrix:{value:new l.f},scale:{value:e},dayTex:{type:"t",value:r},auxTex:{type:"t",value:o},nrmTex:{type:"t",value:i}},vertexShader:"precision highp float;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 invViewMatrix;\n\nuniform vec3 cameraPosition;\n\nuniform float scale;\n\nattribute vec3 vertexPos;\nvarying vec3 fragPos;\n\n// sPos : position of sphere in 2D, where the Y should be perpendicular to camera plane\n// s    : sign for either min or max of sphere on X axis of sPos\n// returns additional correction on X axis due to projection\nfloat perspectiveCorrect(vec2 sPos, float s) {\n    float l = sqrt(pow(sPos.y, 2.0) + pow(sPos.x, 2.0));\n    float a = asin(sPos.x / l);\n    float b = asin(scale / l) * s;\n    return ((scale / cos(a + b)) - scale) * s;\n}\n\nvoid main() {\n    /* \n       first we multiply the matrices together for positioning\n       then set rotation part to identity for a billboard effect\n       (where the render plane is always parallel with the near plane)\n    */\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n    // first column\n    modelViewMatrix[0][0] = scale; \n    modelViewMatrix[0][1] = 0.0; \n    modelViewMatrix[0][2] = 0.0; \n\n    // second column\n    modelViewMatrix[1][0] = 0.0; \n    modelViewMatrix[1][1] = scale; \n    modelViewMatrix[1][2] = 0.0; \n\n    // third column\n    modelViewMatrix[2][0] = 0.0; \n    modelViewMatrix[2][1] = 0.0; \n    modelViewMatrix[2][2] = scale; \n\n    // position of render plane vertex relative to camera\n    vec4 viewPos = modelViewMatrix * vec4(vertexPos, 1);\n\n    // position of sphere center relative to camera\n    vec4 spherePos = viewMatrix * modelMatrix[3];\n\n    // extend plane sides for complete render of sphere\n    viewPos.x += perspectiveCorrect(spherePos.xz, vertexPos.x);\n    viewPos.y += perspectiveCorrect(spherePos.yz, vertexPos.y);\n\n    // forward world pos of vertex to fragment shader\n    fragPos = (invViewMatrix * viewPos).xyz;\n\n    // corner positions of plane\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"precision highp float;\n\n#define LIGHT_DIR normalize(vec3(1, 0.3, 1))\n#define PI 3.14159265359\n#define MAX 10000\n\n\n// scatter const\n#define RATIO 0.98\n#define RED_OUT 1.0\n\n#define ATMOS_REACH .1\n#define ATMOS_SCALE 20.0\n#define SHINE_THROUGH 0.48\n\n#define NUM_OUT_SCATTER 1.0\n#define NUM_IN_SCATTER 8.0\n\n#define PH_RAY 0.03\n#define PH_MIE 0.002\n\n\n\nuniform vec3 cameraPosition;\nuniform float scale;\nuniform mat4 invViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sampler2D dayTex;\nuniform sampler2D nrmTex;\nuniform sampler2D auxTex;\n\nvarying vec3 fragPos;\n\nvec2 Sphere(vec3 origin, vec3 ray, float radius);\nvec3 MapUV(vec3 normal, vec3 ray, vec3 lightDir);\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l, float inner, float outer );\n\nvoid main() {\n    float inner = scale * RATIO;\n    float outer = scale;\n\n    vec3 color = vec3(0);\n    \n    // out of screen ray\n    vec3 ray = normalize(cameraPosition - fragPos);\n\n    // atmosphere raycast\n    vec2 outerSphereHits = Sphere(cameraPosition, ray, outer);\n    if (outerSphereHits.x > outerSphereHits.y) {\n        gl_FragColor = vec4(0);\n        return;\n    }\n\n    // planet raycast\n    vec2 innerSphereHits = Sphere(cameraPosition, ray, inner);\n    if (innerSphereHits.x < innerSphereHits.y) {\n        // calculate world normal\n        vec3 worldPos = (ray * innerSphereHits.x);\n        vec3 normalDir = normalize(cameraPosition - worldPos);\n\n        // final earth texture\n        // color = MapUV(normalDir, ray, LIGHT_DIR);\n    }\n\n    // atmosphere normal\n    vec3 worldPos = (ray * outerSphereHits.x);\n    vec3 normalDir = normalize(cameraPosition - worldPos);\n    float atmosL = min (1.0, 2.5 + dot(LIGHT_DIR, normalDir) * 6.0);\n\n    outerSphereHits.y = min(outerSphereHits.y, innerSphereHits.x);\n\n    vec3 I = in_scatter( cameraPosition, ray, -outerSphereHits.yx, LIGHT_DIR, inner, outer);\n    // color += I;\n    color += vec3(pow( I, vec3( 1.0 / 2.2 ) ));\n    color *= atmosL;\n\n    gl_FragColor = vec4(color, 1);\n}\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 Sphere(vec3 origin, vec3 ray, float radius) {\n\tfloat b = dot(origin, ray);\n\tfloat c = dot(origin, origin) - radius * radius;\n\t\n\tfloat d = b * b - c;\n\tif (d < 0.0) {\n\t\treturn vec2(MAX, -MAX);\n\t}\n\n\td = sqrt(d);\n\treturn vec2(b-d, b+d);\n}\n\n\nvec3 MapUV(vec3 normalDir, vec3 ray, vec3 lightDir) {\n    vec2 uv = vec2(\n        0.5 + atan(normalDir.z, -normalDir.x) / (PI * 2.0),\n        0.5 - asin(-normalDir.y) / PI\n    );\n\n    // texture mapping\n    vec3 dayMap = texture2D(dayTex, uv).rgb;\n    vec3 normalMap = texture2D(nrmTex, uv).rgb * 2.0 - 1.0;\n    vec3 auxMap = texture2D(auxTex, uv).rgb;\n    \n    float lit = auxMap.r;\n    float specular = auxMap.g;\n    float cloud = auxMap.b;\n\n\n    // reflection of water\n    vec3 reflectDir = reflect(-lightDir, normalDir);\n    float reflectAmount = pow(max(dot(ray, reflectDir), 0.0), 6.0) * specular;\n\n    dayMap += vec3(reflectAmount) / 2.0;\n\n    // clouds\n    dayMap = mix(dayMap, vec3(1), vec3(cloud));\n\n    // normal mapPIng\n    vec3 npole = (modelMatrix * vec4(0, 1, 0, 0)).xyz;\n    vec3 tangent = -cross(normalDir, npole);\n    vec3 biTangent = -cross(tangent, normalDir);\n    mat3 tbn = mat3(tangent, biTangent, normalDir);\n\n    vec3 normalMapDir = tbn * normalMap;\n\n    // lighting of earth\n    float shadow = max(0.01, dot(normalMapDir, lightDir));\n    dayMap *= shadow;\n\n    dayMap += lit * pow((1.0 - shadow), 4.0);\n\n    return dayMap;\n}\n\n\n\n// // math const\n// const float MAX = 10000.0;\n\n\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      8PI * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phase_ray( float cc ) {\n\treturn ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );\n}\n\n\n\nfloat density( vec3 p, float ph, float d ) {\n\treturn exp( -max( length( p ) - d, 0.0 ) / (ph * ATMOS_REACH) );\n}\n\nfloat optic( vec3 p, vec3 q, float ph, float d ) {\n\tvec3 s = ( q - p ) / NUM_OUT_SCATTER;\n\tvec3 v = p + s * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( float i = 0.0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v, ph, d );\n\t\tv += s;\n\t}\n\tsum *= length( s );\n\t\n\treturn sum;\n}\n\n\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l, float inner, float outer ) {\n\tconst float ph_ray = PH_RAY;\n    const float ph_mie = PH_MIE;\n    \n    const vec3 k_ray = vec3( 3.8, 13.5, 33.1 );\n    const vec3 k_mie = vec3( 27 );\n    const float k_mie_ex = 0.0;\n    \n\tvec3 sum_ray = vec3( 0.0 );\n    vec3 sum_mie = vec3( 0.0 );\n    \n    float n_ray0 = 0.0;\n    float n_mie0 = 0.0;\n    \n\tfloat len = ( e.y - e.x ) / float( NUM_IN_SCATTER );\n    vec3 s = -dir * len;\n\tvec3 v = -o + -dir * ( e.x + len * 0.5 );\n    \n    for ( float i = 0.0; i < NUM_IN_SCATTER; i++ ) {   \n\t\tfloat d_ray = density( v, ph_ray, inner ) * len;\n        float d_mie = density( v, ph_mie, inner ) * len;\n        \n        n_ray0 += d_ray;\n        n_mie0 += d_mie;\n\n        vec2 f = Sphere( v, l, outer * RED_OUT );\n\t\tvec3 u = v - l * f.y;\n        \n        float n_ray1 = optic( v, u, ph_ray, inner );\n        float n_mie1 = optic( v, u, ph_mie, inner );\n\t\t\n        vec3 att = exp( - ( n_ray0 + n_ray1 ) * k_ray - ( n_mie0 + n_mie1 ) * k_mie * k_mie_ex );\n        \n\t\tsum_ray += d_ray * att;\n        sum_mie += d_mie * att;\n\n        v += s; // HACK\n\t}\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n    vec3 scatter =\n        sum_ray * k_ray * phase_ray( cc ) +\n     \tsum_mie * k_mie * phase_mie(SHINE_THROUGH, c, cc );\n    \n\t\n\treturn ATMOS_SCALE * scatter;\n}\n"});return(n=s(this,f(c).call(this,t,a))).onBeforeRender=function(n,e,t,r,o){o.uniforms.invViewMatrix.value=t.matrixWorld},n}return function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&o(n,e)}(c,l["g"]),c}();function d(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}new function n(e){var r=this;!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),d(this,"loop",function(n,e){var t=n.getDelta();r.objc.rotateY(t/3),r.renderer.render(r.scene,r.camera),requestAnimationFrame(r.loop.bind(null,n,e))}),d(this,"onWindowResize",function(){var n=r.renderer.domElement,e=(window.devicePixelRatio,n.clientWidth),t=n.clientHeight;r.camera.aspect=e/t,r.camera.updateProjectionMatrix(),r.renderer.setSize(n.clientWidth,n.clientHeight,!1)}),this.scene=new l.k,this.camera=new l.i(20,window.innerWidth/window.innerHeight,.1,1e3),this.objc=new l.h;var t=new l.h;this.scene.add(this.objc),t.position.z=4,this.objc.add(t),t.add(this.camera);var o=new c(.5);this.scene.add(o),this.renderer=new l.m({canvas:e}),this.renderer.setClearColor(new l.c("black")),this.onWindowResize();var i=new l.b(!0),a=document.getElementById("fps");this.loop(i,a),window.addEventListener("resize",this.onWindowResize,!1)}(document.getElementById("globe"))}},[["tjUo",4,1,2,3]]]);