(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{tjUo:function(e,n,t){"use strict";t.r(n);var p=t("Womt");function d(e){return(d="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function f(e){return(f=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function o(e,n){return(o=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var s=function(){function m(){var n,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,m);var t=new p.a;t.addAttribute("vertexPos",new p.d([1,1,0,-1,1,0,1,-1,0,-1,-1,0],3)),t.setIndex([0,1,2,1,3,2]);var o=(new p.k).load("assets/earth/day-map1.jpg"),r=(new p.k).load("assets/earth/day-map2.jpg"),a=(new p.k).load("assets/earth/normal-map1.jpg"),i=(new p.k).load("assets/earth/normal-map2.jpg"),s=(new p.k).load("assets/earth/combined-map1.jpg"),l=(new p.k).load("assets/earth/combined-map2.jpg"),c=new p.i({uniforms:{invViewMatrix:{value:new p.e},size:{value:1},dayMap1:{type:"t",value:o},dayMap2:{type:"t",value:r},normalMap1:{type:"t",value:a},normalMap2:{type:"t",value:i},combinedMap1:{type:"t",value:s},combinedMap2:{type:"t",value:l}},vertexShader:"precision highp float;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 invViewMatrix;\n\nuniform vec3 cameraPosition;\n\nuniform float size;\n\nattribute vec3 vertexPos;\nvarying vec3 worldPos;\n\n// sPos : position of sphere in 2D, where the Y should be perpendicular to camera plane\n// s    : sign for either min or max of sphere on X axis of sPos\n// returns additional correction on X axis due to projection\nfloat perspectiveCorrect(vec2 sPos, float s) {\n    float l = sqrt(pow(sPos.y, 2.0) + pow(sPos.x, 2.0));\n    float a = asin(sPos.x / l);\n    float b = asin(size / l) * s;\n    return ((size / cos(a + b)) - size) * s;\n}\n\nvoid main() {\n    /* \n       first we multiply the matrices together for positioning\n       then set rotation part to identity for a billboard effect\n       (where the render plane is always parallel with the near plane)\n    */\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n    // first column\n    modelViewMatrix[0][0] = 1.0; \n    modelViewMatrix[0][1] = 0.0; \n    modelViewMatrix[0][2] = 0.0; \n\n    // second column\n    modelViewMatrix[1][0] = 0.0; \n    modelViewMatrix[1][1] = 1.0; \n    modelViewMatrix[1][2] = 0.0; \n\n    // third column\n    modelViewMatrix[2][0] = 0.0; \n    modelViewMatrix[2][1] = 0.0; \n    modelViewMatrix[2][2] = 1.0; \n\n    // position of render plane vertex relative to camera\n    vec4 viewPos = modelViewMatrix * vec4(vertexPos, 1);\n\n    // position of sphere center relative to camera\n    vec4 spherePos = viewMatrix * modelMatrix[3];\n\n    // extend plane sides for complete render of sphere\n    viewPos.x += perspectiveCorrect(spherePos.xz, vertexPos.x);\n    viewPos.y += perspectiveCorrect(spherePos.yz, vertexPos.y);\n\n    // forward world pos of vertex to fragment shader\n    worldPos = (invViewMatrix * viewPos).xyz;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"precision highp float;\n\n#define light normalize(vec3(0.5, 0.5, 1))\n#define pi 3.14159265359\n\nuniform vec3 cameraPosition;\nuniform float size;\nuniform mat4 invViewMatrix;\nuniform mat4 modelMatrix;\n\nuniform sampler2D dayMap1;\nuniform sampler2D dayMap2;\n\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\n\nuniform sampler2D combinedMap1;\nuniform sampler2D combinedMap2;\n\nvarying vec3 worldPos;\n\nbool Sphere(vec3 ray, vec3 pos, float radius, out vec2 dist);\nvec3 MapUV(vec3 normal, vec3 ray);\n\nvoid main() {\n    vec3 ray = normalize(cameraPosition - worldPos);\n\n    vec2 test;\n    if (Sphere(ray, cameraPosition, size, test)) {\n\n        vec3 iPos = (ray * test.x);\n        vec3 iNormal = normalize(cameraPosition - iPos);\n\n        vec3 color = MapUV(iNormal, ray);\n\n        float lit = max(0.0, dot(iNormal, light));\n\n\n        gl_FragColor = vec4(color, 1);\n\n        return;\n    }\n\n    gl_FragColor = vec4(vec3(0), 1);\n}\n\nbool Sphere(vec3 ray, vec3 pos, float radius, out vec2 dist) {\n    dist = vec2(0, 0);\n    vec2 t;\n    vec3 L = -pos;\n\n    float a = dot(ray, ray);\n    float b = 2.0 * dot(ray, L);\n    float c = dot(L, L) - pow(radius, 2.0);\n\n    float discr = b * b - 4.0 * a * c;\n\n    if (discr < 0.0) {\n        return false;\n    } else if (discr == 0.0)\n    {\n        t.x = (-0.5 * b) / a;\n        t.y = t.x;\n    } else {\n        float q = b > 0.0 ?\n            -0.5 * (b + sqrt(discr)) :\n        -0.5 * (b - sqrt(discr));\n\n        t = vec2(q / a, c / q);\n    }\n\n    if (t.x > t.y) {\n        t = t.yx;\n    }\n    dist = t;\n    return true;\n}\n\nvec3 MapUV(vec3 normal, vec3 ray) {\n    vec2 uv = vec2(\n        0.5 + atan(normal.z, -normal.x) / (pi * 2.0),\n        0.5 - asin(-normal.y) / pi\n    );\n\n    // divide world uv for 2 textures\n    vec4 fUV = vec4(\n        vec2(uv.x * 2.0 - 1.0, uv.y),\n        vec2((uv.x * 2.0), uv.y)\n    );\n\n    // texture mapping\n    vec3 map;\n    vec3 nmap;\n\n    float specular = 0.0;\n    float cloud = 0.0;\n    float lit = 0.0;\n\n    if (uv.x > 0.5) {\n        map = texture2D(dayMap1, fUV.xy).rgb;\n        nmap = texture2D(normalMap1, fUV.xy).rgb;\n\n        vec3 combined = texture2D(combinedMap1, fUV.xy).rgb;\n        specular = combined.r;\n        cloud = combined.g;\n        lit = combined.b;\n    } else {\n        map = texture2D(dayMap2, fUV.zw).rgb;\n        nmap = texture2D(normalMap2, fUV.zw).rgb;\n\n        vec3 combined = texture2D(combinedMap2, fUV.zw).rgb;\n        specular = combined.r;\n        cloud = combined.g;\n        lit = combined.b;\n    }\n\n    nmap = nmap * 2.0 - 1.0;\n\n    vec3 color = map.xyz;\n\n    // for a stable light\n    vec3 lightTest = (invViewMatrix * vec4(light, 0)).rgb;\n\n    // reflection of water\n    vec3 reflectDir = reflect(-lightTest, normal);\n    float r = pow(max(dot(ray, reflectDir), 0.0), 6.0) * specular;\n\n    color += vec3(r) / 1.5;\n\n    // clouds\n    color = mix(color, vec3(1), vec3(cloud));\n\n    // normal mapping\n    mat4 modelCopy = modelMatrix;\n    modelCopy[3][3] = 0.0;\n\n    vec3 npole = (modelCopy * vec4(0, 1, 0, 0)).xyz;\n    vec3 tangent = cross(normal, npole);\n    vec3 biTangent = -cross(tangent, normal);\n\n    mat3 tbn;\n    tbn[0] = tangent;\n    tbn[1] = biTangent;\n    tbn[2] = normal;\n\n    nmap.xy *= 2.0;\n    nmap = normalize(nmap);\n\n    vec3 test = tbn * nmap;\n\n    // lighting of earth\n    float shadow = max(0.0, dot(test, lightTest));\n    color *= shadow;\n\n\n\n    return color;\n}"});return function(e,n,t){n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t}(u(n=function(e,n){return!n||"object"!==d(n)&&"function"!=typeof n?u(e):n}(this,f(m).call(this,t,c))),"setSphereSize",function(e){n.material.uniforms.size.value=e}),n.size=e,n.onBeforeRender=function(e,n,t,o,r){r.uniforms.invViewMatrix.value=t.matrixWorld},n}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&o(e,n)}(m,p["f"]),m}();function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}new function e(n){var o=this;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),l(this,"loop",function(e,n){var t=e.getDelta();o.objc.rotateY(t/3),o.renderer.render(o.scene,o.camera),requestAnimationFrame(o.loop.bind(null,e,n))}),l(this,"onWindowResize",function(){var e=o.renderer.domElement,n=(window.devicePixelRatio,e.clientWidth),t=e.clientHeight;o.camera.aspect=n/t,o.camera.updateProjectionMatrix(),o.renderer.setSize(e.clientWidth,e.clientHeight,!1)}),this.scene=new p.j,this.camera=new p.h(20,window.innerWidth/window.innerHeight,.1,1e3),this.objc=new p.g;var t=new p.g;this.scene.add(this.objc),t.position.z=10,this.objc.add(t),t.add(this.camera);var r=new s;this.scene.add(r),r.setSphereSize(1),this.renderer=new p.l({canvas:n}),this.renderer.setClearColor(new p.c("black")),this.onWindowResize();var a=new p.b(!0),i=document.getElementById("fps");this.loop(a,i),window.addEventListener("resize",this.onWindowResize,!1)}(document.getElementById("globe"))}},[["tjUo",2,1]]]);